//
//  SteppingAction.cpp
//  
//
//  Created by David Mazzanti on 2/5/23.
//

#include "SteppingAction.hh"
#include "B4cDetectorConstruction.hh"

#include "G4Step.hh"
#include "G4RunManager.hh"

#include "G4OpticalPhoton.hh"
#include "G4OpBoundaryProcess.hh"

/*
SteppingAction::SteppingAction(B4cDetectorConstruction* detConstruction)
  : fDetConstruction(detConstruction)
{
}
*/

SteppingAction::SteppingAction(B4RunAction* runAct):  fRunAct(runAct)
{
}

SteppingAction::~SteppingAction()
{
}

void SteppingAction::UserSteppingAction(const G4Step* step)
{
    
    G4Track* Track = step->GetTrack();
    G4int parent_id = Track->GetParentID();
    const G4ParticleDefinition* part = Track->GetDefinition();
    // G4int pdg = part->GetPDGEncoding(); // The Particle Data Group integer identifier of this particle
   
    const G4StepPoint* prePoint = step->GetPreStepPoint();
    const G4StepPoint* endPoint = step->GetPostStepPoint();
    const G4String currentPhysicalName = prePoint->GetPhysicalVolume()->GetName();
    const G4String particleName = Track->GetDefinition()->GetParticleName();
   
    FirstIntStep = fRunAct->GetFirstIntFlag();
    
    if (currentPhysicalName == "WorldPV" && FirstIntStep == 0 && parent_id == 0) {
       G4double kinE = Track->GetKineticEnergy();
       fRunAct->SetKinEnergy(kinE);
       FirstIntStep = 1;
       fRunAct->SetFirstIntFlag(FirstIntStep);
    }

  G4OpBoundaryProcessStatus boundaryStatus = Undefined;

  // find the boundary process only once
  if(nullptr == fBoundary && Track->GetDefinition() == G4OpticalPhoton::OpticalPhotonDefinition()) // pdg == -22
  {
    G4ProcessManager* pm = part->GetProcessManager();
    G4int nprocesses = pm->GetProcessListLength();
    G4ProcessVector* pv = pm->GetProcessList();
    for(G4int i = 0; i < nprocesses; ++i)
    {
      if(nullptr != (*pv)[i] && (*pv)[i]->GetProcessName() == "OpBoundary")
      {
        fBoundary = dynamic_cast<G4OpBoundaryProcess*>((*pv)[i]);
        break;
      }
    }
  }




  // Check for optical photons 
  // (more outputs than photons generated since we are checking every step)
  // 
  // G4ParticleDefinition* opticalphoton = G4OpticalPhoton::OpticalPhotonDefinition();
  // const G4ParticleDefinition* particleDef = step->GetTrack()->GetDynamicParticle()->GetParticleDefinition();
  // if(particleDef == opticalphoton){
  //   G4cerr << "I am an optical photon :)" << G4endl;
  // } 
      
  
  // Never get scintillation not sure why :(
  // Probably because sintillation is only a generator process
  // Optical photon post step process (the interation in the step) is always another typer of interaction, never scintillation
  //
  // if(step->GetPostStepPoint()->GetProcessDefinedStep()->GetProcessName() == "Scintillation") {
      // G4cerr << "Process: " << step->GetPostStepPoint()->GetProcessDefinedStep()->GetProcessName() << G4endl;
  // }


  // Check creator process of secondary optical photons
  //
  // if (Track->GetDefinition() == G4OpticalPhoton::OpticalPhotonDefinition()) {  // particle is optical photon
  //       if (Track->GetParentID() > 0) {  // particle is secondary
  //         G4cerr << "Optical photon generated by: " << Track->GetCreatorProcess()->GetProcessName() << G4endl;
  //       }
  //     }

 
}
